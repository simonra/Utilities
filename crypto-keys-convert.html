<!DOCTYPE html>
<html>
<head>
	<title>Fun with encryption keys!</title>
	<meta charset="utf-8">
	<script type="text/javascript">
		/*
		Convert a string into an ArrayBuffer
		from https://developers.google.com/web/updates/2012/06/How-to-convert-ArrayBuffer-to-and-from-String
		*/
		function str2ab(str) {
			const buf = new ArrayBuffer(str.length);
			const bufView = new Uint8Array(buf);
			for (let i = 0, strLen = str.length; i < strLen; i++) {
				bufView[i] = str.charCodeAt(i);
			}
			return buf;
		}

		function getB64StringFromByteArray(octets){
			var decoder = new TextDecoder('utf-8');
			var stringificationOfOctetArray = decoder.decode(octets);
			var b64EncodedResult = btoa(stringificationOfOctetArray);
			return b64EncodedResult;
		}

		function testGetB64StringFromByteArray(){
			console.log("Beginning testing getB64StringFromByteArray.")
			var raw = new Uint8Array([1,0,1]);
			var encoded = getB64StringFromByteArray(raw);
			console.assert(
				encoded == "AQAB",
				`Failed to get Base64 encoded string from byte array. Expected "AQAB" but got "${encoded}".`
			);
			console.log("Finised testing getB64StringFromByteArray.")
		}

		/* Convert base64 data to hex string. https://stackoverflow.com/a/57909068/2890086
		*   txt : Base64 string.
		*   sep : Hex separator, e.g. '-' for '1a-2b-3c'.  Default empty.
		*/
		const base64ToHex = ( () => {
			// Lookup tables
			const values = [], output = [];

			// Main converter
			return function base64ToHex ( txt, sep = '' ) {
				if ( output.length <= 0 ) {
					populateLookups();
				}
				const result = [];
				let v1, v2, v3, v4;
				for ( let i = 0, len = txt.length ; i < len ; i += 4 ) {
					// Map four chars to values.
					v1 = values[ txt.charCodeAt( i   ) ];
					v2 = values[ txt.charCodeAt( i+1 ) ];
					v3 = values[ txt.charCodeAt( i+2 ) ];
					v4 = values[ txt.charCodeAt( i+3 ) ];
					// Split and merge bits, then map and push to output.
					result.push(
						output[ ( v1 << 2) | (v2 >> 4) ],
						output[ ((v2 & 15) << 4) | (v3 >> 2) ],
						output[ ((v3 &  3) << 6) |  v4 ]
					);
				}
				// Trim result if the last values are '='.
				if ( v4 === 64 ) {
					result.splice( v3 === 64 ? -2 : -1 );
				}
				return result.join( sep );
			};

			function populateLookups () {
				const keys = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
				for ( let i = 0 ; i < 256 ; i++ ) {
					output.push( ( '0' + i.toString( 16 ) ).slice( -2 ) );
					values.push( 0 );
				}
				for ( let i = 0 ; i <  65 ; i++ ) {
					values[ keys.charCodeAt( i ) ] = i;
				}
			}
		} )();

		// look up tables
		var to_hex_array = [];
		var to_byte_map = {};
		function populateLookupTablesForConversionBetweenHexAndByte(){
			if(to_hex_array > 1){
				return;
			}
			for (var ord=0; ord<=0xff; ord++) {
				var s = ord.toString(16);
				if (s.length < 2) {
					s = "0" + s;
				}
				to_hex_array.push(s);
				to_byte_map[s] = ord;
			}
		}
		// converter using lookups
		function bufferToHexString(buffer, separator = '') {
			populateLookupTablesForConversionBetweenHexAndByte();
			var hex_array = [];
			//(new Uint8Array(buffer)).forEach((v) => { hex_array.push(to_hex_array[v]) });
			for (var i=0; i<buffer.length; i++) {
				hex_array.push(to_hex_array[buffer[i]]);
			}
			return hex_array.join(separator);
		}
		// reverse conversion using lookups
		function hexToBuffer(s) {
			populateLookupTablesForConversionBetweenHexAndByte();
			var length2 = s.length;
			if ((length2 % 2) != 0) {
				throw "hex string must have length a multiple of 2";
			}
			var length = length2 / 2;
			var result = new Uint8Array(length);
			for (var i=0; i<length; i++) {
				var i2 = i * 2;
				var b = s.substring(i2, i2 + 2);
				result[i] = to_byte_map[b];
			}
			return result;
		}

		function hexStringToByteArray(hexString, separator){
			var hexBytesInArray = hexString.split(separator)
			var hexBytesWithCustomaryPrefixInArray = hexBytesInArray.map(byte => `0x${byte}`);
			var parsedToByteArray = new Uint8Array(hexBytesWithCustomaryPrefixInArray);
			return parsedToByteArray;
		}

		// function byteArrayToHexArray(uint8ByteArray){
		// 	return uint8ByteArray.map(byte => byte.toString(16));
		// }

		function hexArrayToString(hexArray, separator = ''){
			const reducer = (accumulator, currentValue) => accumulator + separator + `${currentValue}`;
			var folded = hexArray.reduce(reducer);
			return folded;
		}

		function base64ToUint8Array(b64Text) {
			var hexSeparator = ':';
			var asHexString = base64ToHex(b64Text, hexSeparator);
			var asUint8Array = hexStringToByteArray(asHexString, hexSeparator);
			return asUint8Array;
		}

		let BerAsn1Classes = {
			// These are the possible classes outlined in the 2 leftmost bits. When unpacked should be found in the "cls" field.
			Universal: {
				Name: 'Universal',
				Value: 0,
				Description: 'The type is native to ASN.1'
			},
			Application: {
				Name: 'Application',
				Value: 1,
				Description: 'The type is only valid for one specific application'
			},
			ContextSpecific: {
				Name: 'Context-specific',
				Value: 2,
				Description: 'Meaning of this type depends on the context (such as within a sequence, set or choice)'
			},
			Private: {
				Name: 'Private',
				Value: 3,
				Description: 'Defined in private specifications'
			}
		};
		let BerAsn1PCBit = {
			// When unpacked should be found in the "structured" field.
			P: {
				Name: 'Primitive',
				Value: 0,
				Description: 'The contents octets directly encode the element value.'
			},
			C: {
				Name: 'Constructed',
				Value: 1,
				Description: 'The contents octets contain 0, 1, or more element encodings.'
			}
		};
		let BerAsn1NativeTypes = {
			// These are the ASN.1 native types that are permitted used with the Universal class. If used, can be found in the tag field.
			EndOfContentTag: {
				Name: 'End-of-Content (EOC)',
				PermittedConstruction: 'Primitive',
				TagNumberDecimal: 0,
				TagNumberHex: '0'
			},
			BooleanTag: {
				Name: 'BOOLEAN',
				PermittedConstruction: 'Primitive',
				TagNumberDecimal: 1,
				TagNumberHex: '1'
			},
			IntegerTag: {
				Name: 'INTEGER',
				PermittedConstruction: 'Primitive',
				TagNumberDecimal: 2,
				TagNumberHex: '2'
			},
			BitStringTag: {
				Name: 'BIT STRING',
				PermittedConstruction: 'Both',
				TagNumberDecimal: 3,
				TagNumberHex: '3'
			},
			OctetStringTag: {
				Name: 'OCTET STRING',
				PermittedConstruction: 'Both',
				TagNumberDecimal: 4,
				TagNumberHex: '4'
			},
			NullTag: {
				Name: 'NULL',
				PermittedConstruction: 'Primitive',
				TagNumberDecimal: 5,
				TagNumberHex: '5'
			},
			ObjectIdentifierTag: {
				Name: 'OBJECT IDENTIFIER',
				PermittedConstruction: 'Primitive',
				TagNumberDecimal: 6,
				TagNumberHex: '6'
			},
			ObjectDescriptorTag: {
				Name: 'Object Descriptor',
				PermittedConstruction: 'Both',
				TagNumberDecimal: 7,
				TagNumberHex: '7'
			},
			ExternalTag: {
				Name: 'EXTERNAL',
				PermittedConstruction: 'Constructed',
				TagNumberDecimal: 8,
				TagNumberHex: '8'
			},
			RealFloatTag: {
				Name: 'REAL (float)',
				PermittedConstruction: 'Primitive',
				TagNumberDecimal: 9,
				TagNumberHex: '9'
			},
			EnumeratedTag: {
				Name: 'ENUMERATED',
				PermittedConstruction: 'Primitive',
				TagNumberDecimal: 10,
				TagNumberHex: 'A'
			},
			EmbeddedPdvTag: {
				Name: 'EMBEDDED PDV',
				PermittedConstruction: 'Constructed',
				TagNumberDecimal: 11,
				TagNumberHex: 'B'
			},
			Utf8StringTag: {
				Name: 'UTF8String',
				PermittedConstruction: 'Both',
				TagNumberDecimal: 12,
				TagNumberHex: 'C'
			},
			RelativeOidTag: {
				Name: 'RELATIVE-OID',
				PermittedConstruction: 'Primitive',
				TagNumberDecimal: 13,
				TagNumberHex: 'D'
			},
			TimeTag: {
				Name: 'TIME',
				PermittedConstruction: 'Primitive',
				TagNumberDecimal: 14,
				TagNumberHex: 'E'
			},
			ReservedTag: {
				Name: 'Reserved',
				PermittedConstruction: 'N/A',
				TagNumberDecimal: 15,
				TagNumberHex: 'F'
			},
			SequenceAndSequenceOfTag: {
				Name: 'SEQUENCE and SEQUENCE OF',
				PermittedConstruction: 'Constructed',
				TagNumberDecimal: 16,
				TagNumberHex: '10'
			},
			SetAndSetOfTag: {
				Name: 'SET and SET OF',
				PermittedConstruction: 'Constructed',
				TagNumberDecimal: 17,
				TagNumberHex: '11'
			},
			NumericStringTag: {
				Name: 'NumericString',
				PermittedConstruction: 'Both',
				TagNumberDecimal: 18,
				TagNumberHex: '12'
			},
			PrintableStringTag: {
				Name: 'PrintableString',
				PermittedConstruction: 'Both',
				TagNumberDecimal: 19,
				TagNumberHex: '13'
			},
			T61StringTag: {
				Name: 'T61String',
				PermittedConstruction: 'Both',
				TagNumberDecimal: 20,
				TagNumberHex: '14'
			},
			VideotexStringTag: {
				Name: 'VideotexString',
				PermittedConstruction: 'Both',
				TagNumberDecimal: 21,
				TagNumberHex: '15'
			},
			IA5StringTag: {
				Name: 'IA5String',
				PermittedConstruction: 'Both',
				TagNumberDecimal: 22,
				TagNumberHex: '16'
			},
			UTCTimeTag: {
				Name: 'UTCTime',
				PermittedConstruction: 'Both',
				TagNumberDecimal: 23,
				TagNumberHex: '17'
			},
			GeneralizedTimeTag: {
				Name: 'GeneralizedTime',
				PermittedConstruction: 'Both',
				TagNumberDecimal: 24,
				TagNumberHex: '18'
			},
			GraphicStringTag: {
				Name: 'GraphicString',
				PermittedConstruction: 'Both',
				TagNumberDecimal: 25,
				TagNumberHex: '19'
			},
			VisibleStringTag: {
				Name: 'VisibleString',
				PermittedConstruction: 'Both',
				TagNumberDecimal: 26,
				TagNumberHex: '1A'
			},
			GeneralStringTag: {
				Name: 'GeneralString',
				PermittedConstruction: 'Both',
				TagNumberDecimal: 27,
				TagNumberHex: '1B'
			},
			UniversalStringTag: {
				Name: 'UniversalString',
				PermittedConstruction: 'Both',
				TagNumberDecimal: 28,
				TagNumberHex: '1C'
			},
			CharacterStringTag: {
				Name: 'CHARACTER STRING',
				PermittedConstruction: 'Constructed',
				TagNumberDecimal: 29,
				TagNumberHex: '1D'
			},
			BMPStringTag: {
				Name: 'BMPString',
				PermittedConstruction: 'Both',
				TagNumberDecimal: 30,
				TagNumberHex: '1E'
			},
			DateTag: {
				Name: 'DATE',
				PermittedConstruction: 'Primitive',
				TagNumberDecimal: 31,
				TagNumberHex: '1F'
			},
			TimeOfDayTag: {
				Name: 'TIME-OF-DAY',
				PermittedConstruction: 'Primitive',
				TagNumberDecimal: 32,
				TagNumberHex: '20'
			},
			DateTimeTag: {
				Name: 'DATE-TIME',
				PermittedConstruction: 'Primitive',
				TagNumberDecimal: 33,
				TagNumberHex: '21'
			},
			DurationTag: {
				Name: 'DURATION',
				PermittedConstruction: 'Primitive',
				TagNumberDecimal: 34,
				TagNumberHex: '22'
			},
			OidIriTag: {
				Name: 'OID-IRI',
				PermittedConstruction: 'Primitive',
				TagNumberDecimal: 35,
				TagNumberHex: '23'
			},
			RelativeOidIriTag: {
				Name: 'RELATIVE-OID-IRI',
				PermittedConstruction: 'Primitive',
				TagNumberDecimal: 36,
				TagNumberHex: '24'
			}
		};

		function getAsn1ClassByValue(integerValue){
			for(asn1Class in BerAsn1Classes){
				if(BerAsn1Classes[asn1Class]["Value"] == integerValue){
					return BerAsn1Classes[asn1Class];
				}
			}
		}

		function getAsn1TagByValue(integerValue){
			for(asn1tag in BerAsn1NativeTypes){
				if(BerAsn1NativeTypes[asn1tag]["TagNumberDecimal"] == integerValue){
					return BerAsn1NativeTypes[asn1tag];
				}
			}
		}

		function getAsn1ContructedByValue(integerValue){
			if(integerValue == 0){
				return BerAsn1PCBit["P"];
			}
			else if (integerValue == 1){
				return BerAsn1PCBit["C"];
			}
		}

		function berIsConstructed(ber){
			return ber.constructed.Value == BerAsn1PCBit.C.Value;
		}

		function getSubArray(array, startAtInclusive, endAtExclusive){
			return array.slice(startAtInclusive, endAtExclusive);
		}

		/* Because DER is just a stricter subset of BER, and I'd never want to do unot others something as horrible as making them have to deal with either, this function just de-obfuscates the general case and puts it into a malleable json string.
		X.609 details: https://en.wikipedia.org/wiki/X.690
		ToDo: Correct comment and signature to indicate that this only makes a native JS object, could still be sub-components that are DER/BER encoded. 
		*/

		function testWithPredefinedValue(){
			var contentb64 = "MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQDgMCMl4x0KxR/sf9RYARituR/DQ1BGsWBtdytayHuoXNeXAzVt/JTl+QBPtsmvjiJxX/Nw22K/uradc6wg1b+EGOKY7SDtBew/SBdHiZyVs6/zQEuSLscxFxv+SlrHLQi2sjvXFUdC3b7AA9qxT+pdUXzp2zYXk95+/O1feJSaJSkG04Vmnl9zldVESANOKNhTM6t7Mjtlofr7GqJSP1OCEz4tIizWdM7OFMMlEQy4AocoRuHZbxHIbf3ZwEvPOtRBvpJ2vG82mkc6QewN9rulpYd8Q6+A4I01nhJ9GnsXMgGlcYJWfWPCdAjVGkAMZHg3Bdl3zs4Kl0xVLs5mgB4LAgMBAAECggEAOaU3DHFrEM9iJ4ow/BYAFf9xguBmnl7SqCMJ01SUs1R4HPz2uprFYKLXqSebkZgPFC7zZlQK/rjQZwkMu/6qOZm6fk8O9dNdjWIIllz0leu3tOkV5XdAwccq7AaLdAaI5I1M5L+0bKWe/DmhfJFLdoZTA8DZllNv1SBNGwzizQWA3hKI+Zk28eZLsJ3E5I0ZYmmvvvi4Ftbc/ZwLD9ihRWN4UXgXRthvBxsyB8mP0W+SpyhIzfBrgR3Ds6ClvrRoPHqfqjwZFxnnzSKULgOw8LW2lZNsvrWa0DmILA81iRMzaJ7Cs2bIPAjr1h3mEsvOUWnWVOxGBIWY1dH4hPBdoQKBgQD0r9nc0g5mujep/mC182dFvX+MfyjyKNsU5vFcIClIBwXj0PYuUU2ZQCnL6YtdshsJmCalLMAyZ5kuyPf4TeR1bYxwbmUAE8FdtcOxRWncxXPZRTjOWi6qnEJInjZB2s87qv8CZABBNyX4iN7O8RYCHQrWveY7vUr+LT57LRArawKBgQDqjaiaeRP6SX5pZH4GVjyeCfxuJxrS4w539qDd7DWzw7eX+lEoE9gOQNcZyyJGvamhFbqPinnY773RuchvOXLixN6lTgGBg8y48xq6WlKQ88vgrUcrd0+cXwh0/oWltOd6q0YokCeBfnVIVMYbcE4OmSlfGCXDjGMA7G3NTBgf4QKBgBw344Ip32tNcnnyUijppzFNx1XmnExBFfL1J0SemOQrmyxIvvtcePyBf9B6YI4vqhqTJ3HJFWk6tVnF54MFSKGaPqYAtTkrDhPGkIjzHmBNjSyzZPe3QsZ+Os6xIES7/UY+VCZsbfMXbxOYhUmMWCNqQgO95r1g+TMS+K+v5Lt9AoGAMWHdy5gOUrXCfaIAvojNfmCP2wk0po3TcAJm4BJpRA3Cy6aSC6QR6v5Py0hvUQGBgz615p67BKeFCXDZ+EDaJVBZp+gCfSgopA/a4r09gPMzS3xv7YDTLBL+DtO/g6HQ0ozY2pVvG95qBu6CPyin5n7srO7ClKcr+PfOLlkFA0ECgYEAxTwAs/r0qnSpTnVSyi7QeMabcPagEybYnMTDpoPyw4ZsIdarfFiQKEOaX82M9YsxEPXNIGoAx/TjF+g799jPd+dFBoFIFwCav2Lh3DeMfms6cCvFE0jMXRjfvIafeQDzNm6xsqtwXf+XYOsiFZYBNoK3/sctX/rE1GaeGJG979w=";
			var outerBer = parseBerFromB64EncodedString(contentb64);
			var parsedRsaKey = parseRsaKeyFromUnpackedBer(outerBer);
			return parsedRsaKey;
			// ToDo: When you unpack it you should get a large entry that is typed as "OCTET STRING", which is the actual content looked for, which you can unpack with parseAsn1BerAndUnpackNestedAsn1EncodedSequences(). The creators in their infinite wisdom did not see fit to require that it be tagged as constructed so that it could be easily unpacked immediately. A great thanks to those guys, along with the people who forsaked reason and chose ASN.1 in the first place, not to forget an honorable mention of the cursed individuals who came up with the ASN.1 OID encoding scheme and locked it to a bound amout of issuing organizations.
		}

		function parseRsaFromB64EncodedPemString(b64PemContent){
			var outerPackaging = parseBerFromB64EncodedString(b64PemContent);
			var parsedRsaKey = parseRsaKeyFromUnpackedBer(outerPackaging);
			return parsedRsaKey;
		}

		function parseBerFromB64EncodedString(b64Input){
			// var contentAsHexString = base64ToHex(b64Input, ':');
			// console.log(contentAsHexString);
			var contentAsByteArray = base64ToUint8Array(b64Input);
			// console.log(contentAsByteArray);
			var parsedBer = parseAsn1BerAndUnpackNestedAsn1EncodedSequences(contentAsByteArray);
			return parsedBer;
			// return 
		}

		function parseRsaKeyFromUnpackedBer(arrayOfParsedBerParts){
			// Expected format for RSA private key: https://datatracker.ietf.org/doc/html/rfc3447#appendix-A
			var parsedBerIsRsaKey = unpackedBerArrayIsRsaKey(arrayOfParsedBerParts);
			if(parsedBerIsRsaKey.isRsaKey){
				var encodedRsaKey = getSingleOctetArrayThatIsPrimitive(arrayOfParsedBerParts);
				var decodedRsaKeyParts = parseAsn1BerAndUnpackNestedAsn1EncodedSequences(encodedRsaKey);
				var rsaPrivateKey = {};
				rsaPrivateKey.version = decodedRsaKeyParts[0];
				rsaPrivateKey.modulus = decodedRsaKeyParts[1]; // n
				rsaPrivateKey.publicExponent = decodedRsaKeyParts[2]; // e
				rsaPrivateKey.privateExponent = decodedRsaKeyParts[3]; // d
				rsaPrivateKey.prime1 = decodedRsaKeyParts[4]; // p
				rsaPrivateKey.prime2 = decodedRsaKeyParts[5]; // q
				rsaPrivateKey.exponent1 = decodedRsaKeyParts[6]; // d mod (p - 1), aka "dp" in jwk-land
				rsaPrivateKey.exponent2 = decodedRsaKeyParts[7]; // d mod (q - 1), aka "dq" in jwk-land
				rsaPrivateKey.coefficient = decodedRsaKeyParts[8]; // (inverse of q) mod p, aka "qi" in jwk-land
				if(rsaPrivateKey.version == 1){
					// ToDo: If this situation ever arises, this should be an encoded sequence.
					rsaPrivateKey.otherPrimeInfos = []; // "oth" in jwk
					if(decodedRsaKeyParts.length > 9){
						rsaPrivateKey.otherPrimeInfos[0] = {};
						rsaPrivateKey.otherPrimeInfos[0].prime1 = decodedRsaKeyParts[9]; // r
						rsaPrivateKey.otherPrimeInfos[0].exponent1 = decodedRsaKeyParts[10]; // d
						rsaPrivateKey.otherPrimeInfos[0].coefficient = decodedRsaKeyParts[11]; // t
					}
				}
				return rsaPrivateKey;
			}
		}

		function getLengthOfRsaModulus(modulusBer){
			var numberOf8BitBytes = modulusBer.content.length;
			var numberOfLeadingZeroBits = getNumberOfLeadingBitsThatAreZero(modulusBer.content);
			var lengthInBits = numberOf8BitBytes * 8 - numberOfLeadingZeroBits;
			return lengthInBits;
		}

		function testGetLengthOfRsaModulus(){
			var modulusBerHexEncoded = "02:82:01:01:00:e0:30:23:25:e3:1d:0a:c5:1f:ec:7f:d4:58:01:18:ad:b9:1f:c3:43:50:46:b1:60:6d:77:2b:5a:c8:7b:a8:5c:d7:97:03:35:6d:fc:94:e5:f9:00:4f:b6:c9:af:8e:22:71:5f:f3:70:db:62:bf:ba:b6:9d:73:ac:20:d5:bf:84:18:e2:98:ed:20:ed:05:ec:3f:48:17:47:89:9c:95:b3:af:f3:40:4b:92:2e:c7:31:17:1b:fe:4a:5a:c7:2d:08:b6:b2:3b:d7:15:47:42:dd:be:c0:03:da:b1:4f:ea:5d:51:7c:e9:db:36:17:93:de:7e:fc:ed:5f:78:94:9a:25:29:06:d3:85:66:9e:5f:73:95:d5:44:48:03:4e:28:d8:53:33:ab:7b:32:3b:65:a1:fa:fb:1a:a2:52:3f:53:82:13:3e:2d:22:2c:d6:74:ce:ce:14:c3:25:11:0c:b8:02:87:28:46:e1:d9:6f:11:c8:6d:fd:d9:c0:4b:cf:3a:d4:41:be:92:76:bc:6f:36:9a:47:3a:41:ec:0d:f6:bb:a5:a5:87:7c:43:af:80:e0:8d:35:9e:12:7d:1a:7b:17:32:01:a5:71:82:56:7d:63:c2:74:08:d5:1a:40:0c:64:78:37:05:d9:77:ce:ce:0a:97:4c:55:2e:ce:66:80:1e:0b";
			var modulusBerAsByteArray = hexStringToByteArray(modulusBerHexEncoded, ':');
			var modulusBerParsed = parseAsn1Ber(modulusBerAsByteArray);
			var parsedLength = getLengthOfRsaModulus(modulusBerParsed);
			console.assert(
				parsedLength == 2048,
				`Failed to obtain correct length of modulus parsed from ber hex. Expected ${2048} but got ${parsedLength}.`
			);
			console.log("Completed testing of reading length of RSA modulus.");
		}

		function getNumberOfLeadingBitsThatAreZero(arrayOfBytes){
			// Note that this assumes that the input is big-endian, and you want to know how many of the leftmost bits are 0.
			var numberOfLeadingZeroBits = 0;
			for (var i = 0; i < arrayOfBytes.length; i++) {
				var countForThis8BitByte = Math.clz32(arrayOfBytes[i]) - 24; // CLZ = count leading zeroes. Seems to exist as far down as assembly, should maybe consider exploring whether webasm has it and is more efficient. Note the subtraction of 24 due to the implementation in Math only being for speciffically 32 bit numbers.
				numberOfLeadingZeroBits += countForThis8BitByte;
				if(countForThis8BitByte < 8){
					break;
				}
			}
			return numberOfLeadingZeroBits;
		}

		function unpackedBerArrayIsRsaKey(arrayOfParsedBerParts){
			var result = {isRsaKey: false, value: null};
			for (var i = 0; i < arrayOfParsedBerParts.length; i++) {
				var currentBer = arrayOfParsedBerParts[i];
				if(currentBer.asn1Class.Value == BerAsn1Classes.Universal.Value && currentBer.asn1Tag.TagNumberDecimal == BerAsn1NativeTypes.ObjectIdentifierTag.TagNumberDecimal){
					var parsedValue = parseOidFromBer(currentBer);
					var rsaKeyOid = "1.2.840.113549.1.1.1";
					if(parsedValue == rsaKeyOid){
						result.isRsaKey = true;
						result.value = parsedValue;
						return result;
					}
				}
			}
			return result;
		}

		function getSingleOctetArrayThatIsPrimitive(arrayOfParsedBerParts){
			// Because obviously tagging the single octet string as a primitive rather than a constructed type it would make sense to automate the unpacking of makes sense.
			for (var i = 0; i < arrayOfParsedBerParts.length; i++) {
				var currentBer = arrayOfParsedBerParts[i];
				if(currentBer.asn1Class.Value == BerAsn1Classes.Universal.Value && currentBer.asn1Tag.TagNumberDecimal == BerAsn1NativeTypes.OctetStringTag.TagNumberDecimal){
					return currentBer.content;
				}
			}
		}

		function parseAsn1BerAndUnpackNestedAsn1EncodedSequences(byteArrayUint8){
			var result = new Array();
			var encodedSequences = new Array();
			var debugAllBersProcessed = new Array();
			var parsedBer = parseAsn1Ber(byteArrayUint8);
			debugAllBersProcessed.push(parsedBer);
			if(berIsConstructed(parsedBer)){
				encodedSequences.push(parsedBer);
			}
			else{
				result.push(parsedBer);
			}
			while(encodedSequences.length > 0){
				var nextSequenceToProcess = encodedSequences.pop();
				var indexNextSubBerStartsAt = 0;
				var totalLength = nextSequenceToProcess.content.length;
				while(indexNextSubBerStartsAt < totalLength){
					nextSubBerBytes = nextSequenceToProcess.content.slice(indexNextSubBerStartsAt); // Get all bytes from start of next sub ber to end. Because length is always specified, we will alwyas stop extracting content before the start of the next entry.
					parsedBer = parseAsn1Ber(nextSubBerBytes);
					debugAllBersProcessed.push(parsedBer);
					indexNextSubBerStartsAt += parsedBer.length;
					if(berIsConstructed(parsedBer)){
						encodedSequences.push(parsedBer);
					}
					else{
						result.push(parsedBer);
					}
				}
			}
			console.log("Debug: All bers processed:");
			console.log(debugAllBersProcessed);
			return result;
		}

		function testParseAsn1BerAndUnpackNestedAsn1EncodedSequences(){
			var simpleIntWith1BytePredefinedLength = [0b00000010, 0b00000001, 0b00110011];
			var parsedSimpleIntWith1BytePredefinedLength = parseAsn1BerAndUnpackNestedAsn1EncodedSequences(simpleIntWith1BytePredefinedLength);
			var assertSimpleIntWith1BytePredefinedLengthPrefix = "Parsing of Asn1Ber of simple integer with 1 byte content failed.";
			console.assert(
				bufferToHexString(parsedSimpleIntWith1BytePredefinedLength[0].content) == bufferToHexString(new Uint8Array([simpleIntWith1BytePredefinedLength[2]])),
				`${assertSimpleIntWith1BytePredefinedLengthPrefix} Expected content to be ${simpleIntWith1BytePredefinedLength[2]} but found ${parsedSimpleIntWith1BytePredefinedLength[0].content}.`
			);
			console.assert(
				parsedSimpleIntWith1BytePredefinedLength[0].length == simpleIntWith1BytePredefinedLength.length,
				`${assertSimpleIntWith1BytePredefinedLengthPrefix} Expected length to be ${simpleIntWith1BytePredefinedLength.length} but found ${parsedSimpleIntWith1BytePredefinedLength[0].length}.`
			);
			console.assert(
				parsedSimpleIntWith1BytePredefinedLength[0].asn1Class.Value == BerAsn1Classes.Universal.Value,
				`${assertSimpleIntWith1BytePredefinedLengthPrefix} Expected class value to be ${BerAsn1Classes.Universal.Value} but found ${parsedSimpleIntWith1BytePredefinedLength[0].asn1Class.Value}.`
			);
			console.assert(
				parsedSimpleIntWith1BytePredefinedLength[0].constructed.Value == BerAsn1PCBit.P.Value,
				`${assertSimpleIntWith1BytePredefinedLengthPrefix} Expected Primitive/Constructed value to be ${BerAsn1PCBit.P.Value} but found ${parsedSimpleIntWith1BytePredefinedLength[0].constructed.Value}.`
			);
			console.assert(
				parsedSimpleIntWith1BytePredefinedLength[0].asn1Tag.TagNumberDecimal == BerAsn1NativeTypes.IntegerTag.TagNumberDecimal,
				`${assertSimpleIntWith1BytePredefinedLengthPrefix} Expected tag value to be ${BerAsn1NativeTypes.IntegerTag.TagNumberDecimal} but found ${parsedSimpleIntWith1BytePredefinedLength[0].asn1Tag.TagNumberDecimal}.`
			);

			var simpleIntWith3Bytes = [0b00000010, 0b00000011, 0b00000000, 0b11111111, 0b00110011];
			var simpleIntWith2Bytes = [0b00000010, 0b00000010, 0b00000000, 0b01010101];
			// Sequence header: 0b00110000; class 00 concat P/C 1 concat tag 10000 => 0b00110000
			// Length: simpleIntWith3Bytes.length + simpleIntWith2Bytes.length = 0b1001
			var SecuenceOfInts = [0b00110000, 0b00001001].concat(simpleIntWith3Bytes).concat(simpleIntWith2Bytes);
			// console.log(SecuenceOfInts.reduce((accumulator, currentValue) => accumulator + ", " + `${(currentValue).toString(2).padStart(8,"0")}`));
			var parsedBerFromSecuenceOfInts = parseAsn1BerAndUnpackNestedAsn1EncodedSequences(SecuenceOfInts);
			assertSecuenceOfIntsPrefix = 'Parsing of of Asn1Ber of sequence of 2 integers failed.';
			console.assert(
				parsedBerFromSecuenceOfInts.length == 2,
				`${assertSecuenceOfIntsPrefix} Expected result to be array with the 2 integer bers, but found length to be ${parsedBerFromSecuenceOfInts.length}.`
			);
			console.assert(
				parsedBerFromSecuenceOfInts[0].length == simpleIntWith3Bytes.length,
				`${assertSecuenceOfIntsPrefix} Expected first element of result to be of same size as first integer, ${simpleIntWith3Bytes.length}, but instead found the length to be ${parsedBerFromSecuenceOfInts[0].length}.`
			);
			console.assert(
				bufferToHexString(parsedBerFromSecuenceOfInts[0].content) == bufferToHexString(simpleIntWith3Bytes.slice(2)),
				`${assertSecuenceOfIntsPrefix} Expected first element content to be ${simpleIntWith3Bytes.slice(2)}, but instead found the length to be ${parsedBerFromSecuenceOfInts[0].content}.`
			);
			console.assert(
				parsedBerFromSecuenceOfInts[1].length == simpleIntWith2Bytes.length,
				`${assertSecuenceOfIntsPrefix} Expected second element of result to be of same size as second integer, ${simpleIntWith2Bytes.length}, but instead found the length to be ${parsedBerFromSecuenceOfInts[1].length}.`
			);
			console.assert(
				bufferToHexString(parsedBerFromSecuenceOfInts[1].content) == bufferToHexString(simpleIntWith2Bytes.slice(2)),
				`${assertSecuenceOfIntsPrefix} Expected second element content to be ${simpleIntWith2Bytes.slice(2)}, but instead found the length to be ${parsedBerFromSecuenceOfInts[1].content}.`
			);

			console.log('Finished testing parseAsn1BerAndUnpackNestedAsn1EncodedSequences');
		}

		function parseAsn1Ber(byteArrayUint8){
			var result = {};

			var parsedClassValue = getAsn1Class(byteArrayUint8[0]);
			result.asn1Class = getAsn1ClassByValue(parsedClassValue);

			var parsedConstructedValue = getConstructed(byteArrayUint8[0]);
			result.constructed = getAsn1ContructedByValue(parsedConstructedValue);

			var parsedTag = getAsn1Tag(byteArrayUint8);
			result.asn1Tag = getAsn1TagByValue(parsedTag.Value);

			var firstLengthByteIndex = parsedTag.IndexOfLastByteWithTagInDocument + 1;
			var parsedContentLenght = getLength(byteArrayUint8, firstLengthByteIndex);

			var firstContentByteIndex = parsedContentLenght.IndexOfLastByteSpecifyingSizeInDocument + 1;
			result.content = getContent(byteArrayUint8, firstContentByteIndex, parsedContentLenght.Length, parsedContentLenght.Indefinite);
			result.contentAsHexString = bufferToHexString(result.content, ':');
			// result.inputAsHexString = bufferToHexString(byteArrayUint8, ':');
			result.input = byteArrayUint8;

			var totalLengthFromStartToEndOfContent = firstContentByteIndex + result.content.length;
			if(parsedContentLenght.Indefinite){
				totalLengthFromStartToEndOfContent += 2; // Account for the adittional end of content tags/bytes.
			}
			result.length = totalLengthFromStartToEndOfContent;
			return result;
		}

		function testParseAsn1Ber(){
			var simpleIntWith1BytePredefinedLength = [0b00000010, 0b00000001, 0b00110011];

			var parsedSimpleIntWith1BytePredefinedLength = parseAsn1Ber(simpleIntWith1BytePredefinedLength);
			var assertSimpleIntWith1BytePredefinedLengthPrefix = "Parsing of Asn1Ber of simple integer with 1 byte content failed.";
			console.assert(
				bufferToHexString(parsedSimpleIntWith1BytePredefinedLength.content) == bufferToHexString(new Uint8Array([simpleIntWith1BytePredefinedLength[2]])),
				`${assertSimpleIntWith1BytePredefinedLengthPrefix} Expected content to be ${simpleIntWith1BytePredefinedLength[2]} but found ${parsedSimpleIntWith1BytePredefinedLength.content}.`
			);
			console.assert(
				parsedSimpleIntWith1BytePredefinedLength.length == simpleIntWith1BytePredefinedLength.length,
				`${assertSimpleIntWith1BytePredefinedLengthPrefix} Expected length to be ${simpleIntWith1BytePredefinedLength.length} but found ${parsedSimpleIntWith1BytePredefinedLength.length}.`
			);
			console.assert(
				parsedSimpleIntWith1BytePredefinedLength.asn1Class.Value == BerAsn1Classes.Universal.Value,
				`${assertSimpleIntWith1BytePredefinedLengthPrefix} Expected class value to be ${BerAsn1Classes.Universal.Value} but found ${parsedSimpleIntWith1BytePredefinedLength.asn1Class.Value}.`
			);
			console.assert(
				parsedSimpleIntWith1BytePredefinedLength.constructed.Value == BerAsn1PCBit.P.Value,
				`${assertSimpleIntWith1BytePredefinedLengthPrefix} Expected Primitive/Constructed value to be ${BerAsn1PCBit.P.Value} but found ${parsedSimpleIntWith1BytePredefinedLength.constructed.Value}.`
			);
			console.assert(
				parsedSimpleIntWith1BytePredefinedLength.asn1Tag.TagNumberDecimal == BerAsn1NativeTypes.IntegerTag.TagNumberDecimal,
				`${assertSimpleIntWith1BytePredefinedLengthPrefix} Expected tag value to be ${BerAsn1NativeTypes.IntegerTag.TagNumberDecimal} but found ${parsedSimpleIntWith1BytePredefinedLength.asn1Tag.TagNumberDecimal}.`
			);

			var simpleIntWith3Bytes = [0b00000010, 0b00000011, 0b00000000, 0b11111111, 0b00110011];
			var parsedSimpleIntWith3Bytes = parseAsn1Ber(simpleIntWith3Bytes);
			var assertSimpleIntWith3BytesPrefix = "Parsing of Asn1Ber of simple integer with 3 byte content failed.";
			console.assert(
				bufferToHexString(parsedSimpleIntWith3Bytes.content) == bufferToHexString(simpleIntWith3Bytes.slice(2)),
				`${assertSimpleIntWith3BytesPrefix} Expected content to be ${simpleIntWith3Bytes.slice(2)} but found ${parsedSimpleIntWith3Bytes.content}.`
			);
			console.assert(
				parsedSimpleIntWith3Bytes.length == simpleIntWith3Bytes.length,
				`${assertSimpleIntWith3BytesPrefix} Expected length to be ${simpleIntWith3Bytes.length} but found ${parsedSimpleIntWith3Bytes.length}.`
			);
			console.assert(
				parsedSimpleIntWith3Bytes.asn1Class.Value == BerAsn1Classes.Universal.Value,
				`${assertSimpleIntWith3BytesPrefix} Expected class value to be ${BerAsn1Classes.Universal.Value} but found ${parsedSimpleIntWith3Bytes.asn1Class.Value}.`
			);
			console.assert(
				parsedSimpleIntWith3Bytes.constructed.Value == BerAsn1PCBit.P.Value,
				`${assertSimpleIntWith3BytesPrefix} Expected Primitive/Constructed value to be ${BerAsn1PCBit.P.Value} but found ${parsedSimpleIntWith3Bytes.constructed.Value}.`
			);
			console.assert(
				parsedSimpleIntWith3Bytes.asn1Tag.TagNumberDecimal == BerAsn1NativeTypes.IntegerTag.TagNumberDecimal,
				`${assertSimpleIntWith3BytesPrefix} Expected tag value to be ${BerAsn1NativeTypes.IntegerTag.TagNumberDecimal} but found ${parsedSimpleIntWith3Bytes.asn1Tag.TagNumberDecimal}.`
			);

			var sequenceEncapsulatedRandomness = [0b00110000, 0b00000011, 0b00000000, 0b00000000, 0b00000000];
			var parsedSequenceEncapsulatedRandomness = parseAsn1Ber(sequenceEncapsulatedRandomness);
			var assertSequenceEncapsulatedRandomnessPrefix = "Parsing of Asn1Ber of simple integer with 3 byte content failed.";
			console.assert(
				bufferToHexString(parsedSequenceEncapsulatedRandomness.content) == bufferToHexString(sequenceEncapsulatedRandomness.slice(2)),
				`${assertSequenceEncapsulatedRandomnessPrefix} Expected content to be ${sequenceEncapsulatedRandomness.slice(2)} but found ${parsedSequenceEncapsulatedRandomness.content}.`
			);
			console.assert(
				parsedSequenceEncapsulatedRandomness.length == sequenceEncapsulatedRandomness.length,
				`${assertSequenceEncapsulatedRandomnessPrefix} Expected length to be ${sequenceEncapsulatedRandomness.length} but found ${parsedSequenceEncapsulatedRandomness.length}.`
			);
			console.assert(
				parsedSequenceEncapsulatedRandomness.asn1Class.Value == BerAsn1Classes.Universal.Value,
				`${assertSequenceEncapsulatedRandomnessPrefix} Expected class value to be ${BerAsn1Classes.Universal.Value} but found ${parsedSequenceEncapsulatedRandomness.asn1Class.Value}.`
			);
			console.assert(
				parsedSequenceEncapsulatedRandomness.constructed.Value == BerAsn1PCBit.C.Value,
				`${assertSequenceEncapsulatedRandomnessPrefix} Expected Primitive/Constructed value to be ${BerAsn1PCBit.C.Value} but found ${parsedSequenceEncapsulatedRandomness.constructed.Value}.`
			);
			console.assert(
				parsedSequenceEncapsulatedRandomness.asn1Tag.TagNumberDecimal == BerAsn1NativeTypes.SequenceAndSequenceOfTag.TagNumberDecimal,
				`${assertSequenceEncapsulatedRandomnessPrefix} Expected tag value to be ${BerAsn1NativeTypes.SequenceAndSequenceOfTag.TagNumberDecimal} but found ${parsedSequenceEncapsulatedRandomness.asn1Tag.TagNumberDecimal}.`
			);

			var SequenceElementWithOtherSequenceElementsFollowing = simpleIntWith3Bytes.concat(simpleIntWith1BytePredefinedLength);
			var parsedSequenceElementWithOtherSequenceElementsFollowing = parseAsn1Ber(SequenceElementWithOtherSequenceElementsFollowing);
			var assertSequenceElementWithOtherSequenceElementsFollowingPrefix = "Parsing of Asn1Ber of simple integer with 3 byte content failed.";
			console.assert(
				bufferToHexString(parsedSequenceElementWithOtherSequenceElementsFollowing.content) == bufferToHexString(simpleIntWith3Bytes.slice(2)),
				`${assertSequenceElementWithOtherSequenceElementsFollowingPrefix} Expected content to be ${simpleIntWith3Bytes.slice(2)} but found ${parsedSequenceElementWithOtherSequenceElementsFollowing.content}.`
			);
			console.assert(
				parsedSequenceElementWithOtherSequenceElementsFollowing.length == simpleIntWith3Bytes.length,
				`${assertSequenceElementWithOtherSequenceElementsFollowingPrefix} Expected length to be ${simpleIntWith3Bytes.length} but found ${parsedSequenceElementWithOtherSequenceElementsFollowing.length}.`
			);
			console.assert(
				parsedSequenceElementWithOtherSequenceElementsFollowing.asn1Class.Value == BerAsn1Classes.Universal.Value,
				`${assertSequenceElementWithOtherSequenceElementsFollowingPrefix} Expected class value to be ${BerAsn1Classes.Universal.Value} but found ${parsedSequenceElementWithOtherSequenceElementsFollowing.asn1Class.Value}.`
			);
			console.assert(
				parsedSequenceElementWithOtherSequenceElementsFollowing.constructed.Value == BerAsn1PCBit.P.Value,
				`${assertSequenceElementWithOtherSequenceElementsFollowingPrefix} Expected Primitive/Constructed value to be ${BerAsn1PCBit.P.Value} but found ${parsedSequenceElementWithOtherSequenceElementsFollowing.constructed.Value}.`
			);
			console.assert(
				parsedSequenceElementWithOtherSequenceElementsFollowing.asn1Tag.TagNumberDecimal == BerAsn1NativeTypes.IntegerTag.TagNumberDecimal,
				`${assertSequenceElementWithOtherSequenceElementsFollowingPrefix} Expected tag value to be ${BerAsn1NativeTypes.IntegerTag.TagNumberDecimal} but found ${parsedSequenceElementWithOtherSequenceElementsFollowing.asn1Tag.TagNumberDecimal}.`
			);

			console.log('Testing of parsing of Asn1Ber completed');
		}

		function getAsn1Class(firstByteOfDocument) {
			// Extract fist two bits (from left side) from first byte in ASN.1 encoded document.
			// Interpret first 2 bits as big-endian to obtain ASN.1 class value.
			var asn1Class = firstByteOfDocument >> 6;
			// console.log(`Get ASN.1 class: Processing input "${(firstByteOfDocument).toString(2).padStart(8,"0")}", got "${asn1Class}" as value`);
			// var asn1Class = parseInt((firstByteOfDocument).toString(2).padStart(8,"0").substring(0,2), 2);
			return asn1Class;
		}

		function testGetAsn1Class(){
			var shouldBe0 = 0b00111111;
			var shouldBe1 = 0b01111111;
			var shouldBe2 = 0b10111111;
			var shouldBe3 = 0b11000000;

			var zeroGetsParsedCorrectly = getAsn1Class(shouldBe0) == 0;
			var oneGetsParsedCorrectly = getAsn1Class(shouldBe1) == 1;
			var twoGetsParsedCorrectly = getAsn1Class(shouldBe2) == 2;
			var threeGetsParsedCorrectly = getAsn1Class(shouldBe3) == 3;

			if(zeroGetsParsedCorrectly && oneGetsParsedCorrectly && twoGetsParsedCorrectly && threeGetsParsedCorrectly){
				console.log("All test cases passed for testing parsing of class.");
				return;
			}
			throw `Test failed. zeroGetsParsedCorrectly was ${zeroGetsParsedCorrectly}, oneGetsParsedCorrectly was ${oneGetsParsedCorrectly}, twoGetsParsedCorrectly was ${twoGetsParsedCorrectly}, threeGetsParsedCorrectly was ${threeGetsParsedCorrectly}.`;
		}

		function getConstructed(firstByteOfDocument) {
			// Extract third bit (from left side) from first byte in ASN.1 encoded document.
			// var constructed = (firstByteOfDocument << 2) >> 7;
			// return constructed;
			var isPrimitive = (firstByteOfDocument & 0b00100000) == 0;
			if(isPrimitive){
				return 0;
			}
			return 1;
		}

		function testGetConstructed(){
			var shouldBe0 = 0b11011111;
			var shouldBe1 = 0b00100000;

			var zeroGetsParsedCorrectly = getConstructed(shouldBe0) == 0;
			var oneGetsParsedCorrectly = getConstructed(shouldBe1) == 1;

			if(zeroGetsParsedCorrectly && oneGetsParsedCorrectly){
				console.log("All test cases passed for testing parsing of constructed.");
				return;
			}
			throw `Test failed. zeroGetsParsedCorrectly was ${zeroGetsParsedCorrectly}, oneGetsParsedCorrectly was ${oneGetsParsedCorrectly}.`;
		}

		// Resulting value corresponds to BerAsn1NativeTypes.tagX.NumberValue
		function getAsn1Tag(asn1DocumentAsByteArrayUint8){
			var asn1Tag = {};
			// If five last bits (as read from left) of first byte are all 1, the type is specified in the following bytes.
			// Then, as long as the following bytes have a 1 in the leftmost position, the 7 other bits are concatenated with the same group of bits in the following bytes starting with a 1, which in the end are interpreted as a bit-endian number.
			// Otherwise, if the five last bits of the first byte are not all 1, then they are the tag value (read as big-endian).
			var firstByte = asn1DocumentAsByteArrayUint8[0];
			var lastFiveBits = firstByte & 0b00011111;
			if (lastFiveBits != 0b00011111){
				// By JS magic, this is interpreted and returned as a regular number.
				asn1Tag.Value = lastFiveBits;
				asn1Tag.IndexOfLastByteWithTagInDocument = 0;
				return asn1Tag;
			}

			var currentPosition = 0;
			// var currentByte = asn1DocumentAsByteArrayUint8[currentPosition];
			var stringOfBits = "";
			do {
				currentPosition++;
				currentByte = asn1DocumentAsByteArrayUint8[currentPosition];
				// Get byte as string of bits and remove leading bit we don't care about.
				stringOfBits += (currentByte).toString(2).padStart(8,"0").substring(1);
			} while(currentByte >> 7 != 0);
			var tagNumber = parseInt(stringOfBits, 2);
			asn1Tag.Value = tagNumber;
			asn1Tag.IndexOfLastByteWithTagInDocument = currentPosition;
			return asn1Tag;
		}

		function testGetAsn1Tag(){
			// Note that last byte in all of the samples should not be parsed as part of the tag.
			var shouldBe0 = [0b00000000, 0b11111111, 0b11111111];
			var shouldBe2 = [0b00000010, 0b11111111];
			var shouldBe16 = [0b00010000, 0b11111111];
			var shouldBe16WithCorrectHeaderValueForConstructed = [0b00110000, 0b11111111];
			var shouldBe32 = [0b00011111, 0b00100000, 0b11111111];
			var shouldBe255 = [0b00011111, 0b10000001, 0b01111111, 0b11111111];

			var zeroParsed = getAsn1Tag(shouldBe0);
			var zeroGetsParsedCorrectly = zeroParsed.Value == 0 && zeroParsed.IndexOfLastByteWithTagInDocument == 0;

			var twoParsed = getAsn1Tag(shouldBe2);
			var twoGetsParsedCorrectly = twoParsed.Value == 2 && twoParsed.IndexOfLastByteWithTagInDocument == 0;

			var sixteenParsed = getAsn1Tag(shouldBe16);
			var sixteenGetsParsedCorrectly = sixteenParsed.Value == 16 && sixteenParsed.IndexOfLastByteWithTagInDocument == 0;

			var sixteenWithCorrectHeaderParsed = getAsn1Tag(shouldBe16WithCorrectHeaderValueForConstructed);
			var sixteenWithCorrectHeaderGetsParsedCorrectly = sixteenWithCorrectHeaderParsed.Value == 16 && sixteenWithCorrectHeaderParsed.IndexOfLastByteWithTagInDocument == 0;

			var thirtyTwoParsed = getAsn1Tag(shouldBe32);
			var thirtyTwoGetsParsedCorrectly = thirtyTwoParsed.Value == 32 && thirtyTwoParsed.IndexOfLastByteWithTagInDocument == 1;

			var twoHundredAndFiftyFiveParsed = getAsn1Tag(shouldBe255);
			var twoHundredAndFiftyFiveGetsParsedCorrectly = twoHundredAndFiftyFiveParsed.Value == 255 && twoHundredAndFiftyFiveParsed.IndexOfLastByteWithTagInDocument == 2;

			if(zeroGetsParsedCorrectly
				&& twoGetsParsedCorrectly
				&& sixteenGetsParsedCorrectly
				&& sixteenWithCorrectHeaderGetsParsedCorrectly
				&& thirtyTwoGetsParsedCorrectly
				&& twoHundredAndFiftyFiveGetsParsedCorrectly){
				console.log("All test cases passed for testing parsing of getTag.");
				return;
			}

			throw 'Test failed.'
				+ `zeroGetsParsedCorrectly was ${zeroGetsParsedCorrectly}, `
				+ `twoGetsParsedCorrectly was ${twoGetsParsedCorrectly}, `
				+ `sixteenGetsParsedCorrectly was ${sixteenGetsParsedCorrectly}, `
				+ `sixteenWithCorrectHeaderGetsParsedCorrectly was ${sixteenWithCorrectHeaderGetsParsedCorrectly}, `
				+ `thirtyTwoGetsParsedCorrectly was ${thirtyTwoGetsParsedCorrectly}, `
				+ `twoHundredAndFiftyFiveGetsParsedCorrectly was ${twoHundredAndFiftyFiveGetsParsedCorrectly}.`;
		}

		function getLength(asn1DocumentAsByteArrayUint8, indexOfFirstLengthByte) {
			// There are 4 possible, and 3 allowed ways to specify the length.
			// First, the first length byte can have the first (leftmost) bit set to 0.
			// Then, the following 7 bits of the first byte are interpreted, big endian, as the length of the content in terms of number of bytes representing the content.
			// Note that 0 is a valid length for the content.
			// Second, if the first length byte has the first (leftmost) bit set to 1, and the folliwng 7 are all 0.
			// Then the length is unspecified, and you have to read through the rest of the content untill you hit 2 end-of-content tags in a row.
			// Note that the encoded representation of the end-of-content tag is 1 byte consisting of all 0-s, so you're looking for 2 consecutive bytes that are 0.
			// Third case, the first length byte starts with the first (leftmost) bit set to 1, and the folliwng 7 representing a non zero value lower that 127.
			// Then the 7 last bits (from the left) of the first byte represent (bit-endian) the number of following bytes that describe the length of the content of the document (in terms of numbers of bytes constituting the content/document body).
			// The length-bytes are parsed to a number by mashing them together and interpreting them as a big-endian number (beware leading zeroes).
			// Fourth, the final and unsupported/reserved for future use case.
			// The first bit of the length byte is 1, and all the following bits are also 1 (adding up to 127).
			var result = {
				Length: null,
				Indefinite: false,
				IndexOfLastByteSpecifyingSizeInDocument: indexOfFirstLengthByte
			};
			var firstByte = asn1DocumentAsByteArrayUint8[indexOfFirstLengthByte];
			var firstByteStartsWithZero = firstByte >> 7 == 0;
			if(firstByteStartsWithZero){
				result.Length = firstByte;
				return result;
			}
			if(firstByte == 0b11111111){
				throw "ParsingError: The length byte was all 1's. At the time of writing, that is an unsupported value reserved for future use."
			}
			if(firstByte == 0b10000000){
				result.Indefinite = true;
				return result;
			}
			var numberOfBytesSpecifyingLength = firstByte & 0b01111111;
			stringOfBits = "";
			var longFormLengthStartIndex = indexOfFirstLengthByte + 1;
			result.IndexOfLastByteSpecifyingSizeInDocument = indexOfFirstLengthByte + numberOfBytesSpecifyingLength;
			for (var i = longFormLengthStartIndex; i < result.IndexOfLastByteSpecifyingSizeInDocument + 1; i++) {
				stringOfBits += (asn1DocumentAsByteArrayUint8[i]).toString(2).padStart(8,"0");
			}
			var length = parseInt(stringOfBits, 2);
			result.Length = length;
			return result;
		}

		function testGetLength(){
			var shouldBe0 = [0b00000000, 0b00000000, 0b11111111];
			var shouldBe1 = [0b00000000, 0b00000001, 0b11111111];
			var shouldBeIndefinite = [0b00000000, 0b10000000, 0b11111111];
			var shouldBe256 = [0b00000000, 0b10000010, 0b00000001, 0b00000000, 0b11111111];
			var shouldBe65535 = [0b00000000, 0b10000010, 0b11111111, 0b11111111, 0b00000000];

			var shouldBe0Parsed = getLength(shouldBe0, 1);
			var shouldBe0ParsedCorrectly = shouldBe0Parsed.Length == 0 && shouldBe0Parsed.IndexOfLastByteSpecifyingSizeInDocument == 1 && shouldBe0Parsed.Indefinite == false;
			if(!shouldBe0ParsedCorrectly){
				console.log("Failed to parse shouldBe0Parsed correctly. Result was:");
				console.log(shouldBe0Parsed);
			}

			var shouldBe1Parsed = getLength(shouldBe1, 1);
			var shouldBe1ParsedCorrectly = shouldBe1Parsed.Length == 1 && shouldBe1Parsed.IndexOfLastByteSpecifyingSizeInDocument == 1 && shouldBe1Parsed.Indefinite == false;
			if(!shouldBe1ParsedCorrectly){
				console.log("Failed to parse shouldBe1Parsed correctly. Result was:");
				console.log(shouldBe1Parsed);
			}

			var shouldBeIndefiniteParsed = getLength(shouldBeIndefinite, 1);
			var shouldBeIndefiniteParsedCorrectly = shouldBeIndefiniteParsed.IndexOfLastByteSpecifyingSizeInDocument == 1 && shouldBeIndefiniteParsed.Indefinite == true;
			if(!shouldBeIndefiniteParsedCorrectly){
				console.log("Failed to parse shouldBeIndefiniteParsed correctly. Result was:");
				console.log(shouldBeIndefiniteParsed);
			}

			var shouldBe256Parsed = getLength(shouldBe256, 1);
			var shouldBe256ParsedCorrectly = shouldBe256Parsed.Length == 256 && shouldBe256Parsed.IndexOfLastByteSpecifyingSizeInDocument == 3 && shouldBe256Parsed.Indefinite == false;
			if(!shouldBe256ParsedCorrectly){
				console.log("Failed to parse shouldBe256Parsed correctly. Result was:");
				console.log(shouldBe256Parsed);
			}

			var shouldBe65535Parsed = getLength(shouldBe65535, 1);
			var shouldBe65535ParsedCorrectly = shouldBe65535Parsed.Length == 65535 && shouldBe65535Parsed.IndexOfLastByteSpecifyingSizeInDocument == 3 && shouldBe65535Parsed.Indefinite == false;
			if(!shouldBe65535ParsedCorrectly){
				console.log("Failed to parse shouldBe65535Parsed correctly. Result was:");
				console.log(shouldBe65535Parsed);
			}

			shouldBe128 = [0b00000010, 0b10000001, 0b10000000, 0b00000000];
			var shouldBe128Parsed = getLength(shouldBe128, 1);
			var assertShouldBe128Prefix = "Parsing of length from shouldBe128 failed."
			console.assert(
				shouldBe128Parsed.Length == 128,
				`${assertShouldBe128Prefix} Expected parsed length to be 128, but instead got ${shouldBe128Parsed.Length}.`
			);
			console.assert(
				shouldBe128Parsed.IndexOfLastByteSpecifyingSizeInDocument == 2,
				`${assertShouldBe128Prefix} Expected parsed length to indicate that the last byte/octet specifying lenght was at index 2, but instead got index ${shouldBe128Parsed.IndexOfLastByteSpecifyingSizeInDocument}.`
			);
			console.assert(
				shouldBe128Parsed.Indefinite == false,
				`${assertShouldBe128Prefix} Expected parsed lengths indefinite indicator to be false, but instead got ${shouldBe128Parsed.Indefinite}.`
			);

			if(shouldBe0ParsedCorrectly
				&& shouldBe1ParsedCorrectly
				&& shouldBeIndefiniteParsedCorrectly
				&& shouldBe256ParsedCorrectly
				&& shouldBe65535ParsedCorrectly){
				console.log("All test cases passed for testing parsing of GetLength.");
				return;
			}
			throw "Test Failed."
		}

		function getContent(asn1DocumentAsByteArrayUint8, indexOfFirstContentByte, contentLength, contentLengthIsIndefinite){
			if(!contentLengthIsIndefinite){
				return asn1DocumentAsByteArrayUint8.slice(indexOfFirstContentByte,indexOfFirstContentByte + contentLength);
			}

			if(indexOfFirstContentByte + 1 > asn1DocumentAsByteArrayUint8.length){
				throw "ParsingError: Content of indefinite length is not long enough contain end-of-content markers (2 end-of-content ASN.1 tags in a row). Something is wrong.";
			}
			if (indexOfFirstContentByte + 1 == asn1DocumentAsByteArrayUint8.length){
				if(asn1DocumentAsByteArrayUint8[indexOfFirstContentByte] == 0 && asn1DocumentAsByteArrayUint8[indexOfFirstContentByte + 1] == 0){
					return new Uint8Array();
				}
				throw "ParsingError: Content of indefinite length is just barely long enough to only contain 2 end-of-content tags marking end of content (for specifying content of 0-length in a weird way), however it does not specify end of content. Something is missing.";
			}
			if(asn1DocumentAsByteArrayUint8[indexOfFirstContentByte] == 0 && asn1DocumentAsByteArrayUint8[indexOfFirstContentByte + 1] == 0){
					return new Uint8Array();
			}
			var parsedLength = 1;
			var foundEndOfContent = false;
			for (var i = indexOfFirstContentByte; i < asn1DocumentAsByteArrayUint8.length - 2; i++) {
				if(asn1DocumentAsByteArrayUint8[i + 1] == 0 && asn1DocumentAsByteArrayUint8[i + 2] == 0){
					foundEndOfContent = true;
					break;
				}
				parsedLength++;
			}
			if(!foundEndOfContent){
				throw "ParsingError: Reached end of input marked as indefinite length, but did not find end of content marking.";
			}
			return asn1DocumentAsByteArrayUint8.slice(indexOfFirstContentByte,indexOfFirstContentByte + parsedLength);
		}

		function testGetContent(){
			var shouldBe0 = [0b00000000, 0b00000001, 0b00000000, 0b11111111];
			var shouldBe0Parsed = getContent(shouldBe0, 2, 1, false);
			var shouldBe0ParsedCorrectly = shouldBe0Parsed == 0;
			if(!shouldBe0ParsedCorrectly){
				console.log("Failed to parse shouldBe0 correctly. Result was:");
				console.log(shouldBe0Parsed);
			}

			var shouldBe1 = [0b00000010, 0b00000001, 0b00000001, 0b11111111];
			var shouldBe1Parsed = getContent(shouldBe1, 2, 1, false);
			var shouldBe1ParsedCorrectly = shouldBe1Parsed == 1;
			if(!shouldBe1ParsedCorrectly){
				console.log("Failed to parse shouldBe1 correctly. Result was:");
				console.log(shouldBe1Parsed);
			}

			var shouldBeArrayWith2Elements =  [0b00000010, 0b0000010, 0b00000001, 0b11111111, 0b00000001];
			var shouldBeArrayWith2ElementsParsed = getContent(shouldBeArrayWith2Elements, 2, 2, false);
			// var shouldBeArrayWith2ElementsParsedCorrectly = bufferToHexString(shouldBeArrayWith2ElementsParsed) == bufferToHexString([0b00000001, 0b11111111]);
			var shouldBeArrayWith2ElementsParsedCorrectly =
				bufferToHexString(shouldBeArrayWith2ElementsParsed) == bufferToHexString([shouldBeArrayWith2Elements[2], shouldBeArrayWith2Elements[3]]);
			if(!shouldBeArrayWith2ElementsParsedCorrectly){
				console.log("Failed to parse shouldBeArrayWith2Elements correctly. Result was:");
				console.log(shouldBeArrayWith2Elements);
			}

			var shouldBeIndefiniteArrayWith3Elements = [0b00000010, 0b1000000, 0b00000001, 0b11111111, 0b10000001, 0b00000000, 0b00000000];
			var shouldBeIndefiniteArrayWith3ElementsParsed = getContent(shouldBeIndefiniteArrayWith3Elements, 2, null, true);
			var shouldBeIndefiniteArrayWith3ElementsParsedCorrectly =
				bufferToHexString(shouldBeIndefiniteArrayWith3ElementsParsed) == bufferToHexString([shouldBeIndefiniteArrayWith3Elements[2], shouldBeIndefiniteArrayWith3Elements[3], shouldBeIndefiniteArrayWith3Elements[4]]);
			if(!shouldBeIndefiniteArrayWith3ElementsParsedCorrectly){
				console.log("Failed to parse shouldBeIndefiniteArrayWith3ElementsParsedCorrectly correctly. Result was:");
				console.log(shouldBeIndefiniteArrayWith3ElementsParsed);
				console.log("As hex:");
				console.log(bufferToHexString(shouldBeIndefiniteArrayWith3ElementsParsed, ':'));
				console.log("Expected value as hex:");
				console.log(bufferToHexString([shouldBeIndefiniteArrayWith3Elements[2], shouldBeIndefiniteArrayWith3Elements[3], shouldBeIndefiniteArrayWith3Elements[4]], ':'));
			}

			var shouldBeIndefiniteArrayWith0Elements = [0b00000010, 0b1000000, 0b00000000, 0b00000000];
			var shouldBeIndefiniteArrayWith0ElementsParsed = getContent(shouldBeIndefiniteArrayWith0Elements, 2, null, true);
			var shouldBeIndefiniteArrayWith0ElementsParsedCorrectly = bufferToHexString(shouldBeIndefiniteArrayWith0ElementsParsed) == bufferToHexString([]);
			if(!shouldBeIndefiniteArrayWith0ElementsParsedCorrectly){
				console.log("Failed to parse shouldBeIndefiniteArrayWith0ElementsParsedCorrectly correctly. Result was:");
				console.log(shouldBeIndefiniteArrayWith0ElementsParsed);
			}
			console.log("Success!");
		}




		function parseOidFromBer(ber){
			// ToDo Consider input validation here.
			return parseOidFromByteArray(ber.content);
		}

		function parseOidFromByteArray(arrayOfOctets){
			// For a much prettier formatted summary, check out https://crypto.stackexchange.com/a/29116
			// Again, a great thanks to those who made it needlessly difficult to parse ASN.1 encoded OIDs assigned by anyone else than the ITU (International Telecommunications Union) and ISO (International Organization for Standardization), if you want to be able to parse OIDs assigned by those organizations. May they never find peace.
			// So, the way this works. The stuff is encoded as a series of numbers, encoded big endian. As long as the leftmost bit of a byte is 1, then that byte, and the following is part of the current number. Once you reach a byte that statrs with 0, then the following byte belongs to the next number. To parse the collection of bytes constitutin each number, strip the first (leftmost) bit of each byte/octet. Mash them together in a long string, and read it out as a big endian number.
			// The first number is actually a completely mangled representation of 2 separate numbers, but the explanation of how they work will follow at the point where the code begins to extract the values from that mess.
			var hasContent = arrayOfOctets.length > 0;
			if(!hasContent){
				console.error("parseOidFromByteArray received no bytes in given array. How do you expect to extract info from that?");
				return;
			}

			var encodedNumbersAsBitStrings = new Array();
			var currentPartIndex = 0;
			for (var i = 0; i < arrayOfOctets.length; i++) {
				if(encodedNumbersAsBitStrings[currentPartIndex] == undefined){
					encodedNumbersAsBitStrings[currentPartIndex] = '';
				}
				// Remove leftmost bit and add to current part.
				encodedNumbersAsBitStrings[currentPartIndex] += arrayOfOctets[i].toString(2).padStart(8,"0").substring(1);
				if(arrayOfOctets[i] >> 7 == 0){
					currentPartIndex++;
				}
			}

			var encodedNumbersAsIntegers = new Array();
			for (var i = 0; i < encodedNumbersAsBitStrings.length; i++) {
				encodedNumbersAsIntegers[i] = parseInt(encodedNumbersAsBitStrings[i], 2);
			}

			// Abandon all sanity ye who wenture further. The first number, z, encodes the fist 2 parts of the ID, numbers x and y.
			// The relationship is defined as `z = 40 * x + y`, with the constraints that x is in {0, 1, 2}, and if x < 2 then y < 40.
			var z = encodedNumbersAsIntegers[0];
			var x = Math.min(Math.floor(z/40),2);
			var y = z - (40 * x);
			var numbersExceptFirst = encodedNumbersAsIntegers.slice(1);
			var parts = [x, y].concat(numbersExceptFirst);
			var foldingFunc = (accumulator, currentValue) => accumulator + '.' + `${currentValue}`;
			var resultAsString = parts.reduce(foldingFunc);
			return resultAsString;
		}

		function testParseOidFromByteArray(){
			var rsaKeyOidHexEncodedValue = "2a:86:48:86:f7:0d:01:01:01";
			var rsaKeyDecimalExpectedValue = "1.2.840.113549.1.1.1";
			var rsaKeyOidEncodedAsByteArray = hexStringToByteArray(rsaKeyOidHexEncodedValue, ':');
			var parsedOidFromEncodedRsaKeyOid = parseOidFromByteArray(rsaKeyOidEncodedAsByteArray);
			// debugger;
			console.assert(
				parsedOidFromEncodedRsaKeyOid == rsaKeyDecimalExpectedValue,
				`Failed to parse RSA Key OID from ASN.1 encoded value. Expected ${rsaKeyDecimalExpectedValue} but got ${parsedOidFromEncodedRsaKeyOid}.`
			);

			console.log('Completed tests of testParseOidFromByteArray');
		}

		function testRunAllTests(){
			testGetAsn1Class();
			testGetAsn1Tag();
			testGetConstructed();
			testGetContent();
			testGetLength();
			testParseAsn1Ber();
			testParseAsn1BerAndUnpackNestedAsn1EncodedSequences();
			testParseOidFromByteArray();
			testGetLengthOfRsaModulus();
			testGetB64StringFromByteArray();
		}

		function inputKeyFieldChange(){
			writeKeyToOutputTextArea("", 'ConvertKeyOutputTextArea');
			var keyInputTextArea = document.getElementById('ConvertKeyInputTextArea');
			// textAreaById.textContent = keyAsString;
			// textAreaById.value = keyAsString;

			var outputValue = getKeyFromPemString(keyInputTextArea.value);

			writeKeyToOutputTextArea(outputValue, 'ConvertKeyOutputTextArea');
		}

		function getKeyFromPemString(pemStr){
			const pemHeaderPublic = "-----BEGIN PUBLIC KEY-----";
			const pemFooterPublic = "-----END PUBLIC KEY-----";
			const pemHeaderPrivate = "-----BEGIN PRIVATE KEY-----";
			const pemFooterPrivate = "-----END PRIVATE KEY-----";

			if (pemStr.startsWith(pemHeaderPublic)) {
				if(!pemStr.endsWith(pemFooterPublic)){
					throw new TypeError(`Unable to parse input to function as PEM string. Exptected public key input to end with ${pemFooterPublic}. Instead got ${pemStr}.`);
				}
				var content = pemStr.substring(pemHeaderPublic.length, pemStr.length - pemFooterPublic.length);
				return getKeyFromPemStringContentPublicKey(content);
			}
			else if(pemStr.startsWith(pemHeaderPrivate)){
				if(!pemStr.endsWith(pemFooterPrivate)){
					throw new TypeError(`Unable to parse input to function as PEM string. Exptected private key input to end with ${pemFooterPrivate}. Instead got ${pemStr}.`);
				}
				var content = pemStr.substring(pemHeaderPrivate.length, pemStr.length - pemFooterPrivate.length);
				content = content.replace(/[\n\r]/g,"");
				return makeJwkFromPemStringContentRsaPrivateKey(content);
			}
			else {
				throw new TypeError(`Unable to parse input to function as PEM string. Exptected input to begin with either ${pemHeaderPublic} or ${pemHeaderPrivate}. Instead got ${pemStr}.`);
			}
		}

		function getKeyFromPemStringContentPublicKey(pemContentStr){

		}

		function getKeyFromPemStringContentPrivateKey(pemContentStr){
			// // Base64 decode content to get binary data.
			// // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#examples
			const binaryDerString = window.atob(pemContentStr);
			const binaryDerArrayBuffer = str2ab(binaryDerString);

			var parsedRsaPrivateKey = parseRsaFromB64EncodedPemString(pemContentStr);
			// getLengthOfRsaModulus()
			// var algoMetadata = {
			// 	name: "RSA-PSS",
			// 	modulusLength: getLengthOfRsaModulus(parsedRsaPrivateKey.modulus),
			// 	publicExponent: parsedRsaPrivateKey.publicExponent.content),
			// 	hash: "SHA-256"
			// };

			var format = "pkcs8";
			// var algoMetadata = {
			// 	name: "RSA-PSS",
			// 	modulusLength: 2048,
			// 	publicExponent: new Uint8Array([1, 0, 1]),
			// 	hash: "SHA-256",
			// };
			var extractable = true;
			var usages = ["sign"];

			// https://docs.w3cub.com/dom/subtlecrypto/importkey
			return window.crypto.subtle.importKey(
				format, // Format.
				binaryDerArrayBuffer, // keyData, ArrayBuffer or JWK.
				algoMetadata, // Why couldn't this just be parsed from the key that's passed in??
				extractable, // Whether the key should be exportable after the import.
				usages // Key usages, has to be sign for private keys.
			);


			// https://crypto.stackexchange.com/questions/18031/how-to-find-modulus-from-a-rsa-public-key
		}
		// async
		function makeJwkFromPemStringContentRsaPrivateKey(pemContentStr){
			var decodedKey = parseRsaFromB64EncodedPemString(pemContentStr);
// getB64StringFromByteArray()
			var jwk = {};
			jwk.kty = "RSA";
			// jwk.alg = "RS256";// Ommit this because https://datatracker.ietf.org/doc/html/rfc7517#section-4.4 says it's optional and I haven't seen the value in pem encoded keys yet.
			// jwk.key_ops = ["sign"]; // Ommit this because https://datatracker.ietf.org/doc/html/rfc7517#section-4.3 says it's optional
			jwk.n = `${ base64_arraybuffer(decodedKey.modulus.content)}`;
			jwk.e = `${ base64_arraybuffer(decodedKey.publicExponent.content)}`;
			jwk.d = `${base64_arraybuffer(decodedKey.privateExponent.content)}`;
			jwk.p = `${base64_arraybuffer(decodedKey.prime1.content)}`;
			jwk.q = `${base64_arraybuffer(decodedKey.prime2.content)}`;
			jwk.dp = `${base64_arraybuffer(decodedKey.exponent1.content)}`;
			jwk.dq = `${base64_arraybuffer(decodedKey.exponent2.content)}`;
			jwk.qi = `${base64_arraybuffer(decodedKey.coefficient.content)}`;

			var jwkAsJsonString = JSON.stringify(jwk, null, 3);
			// writeKeyToOutputTextArea(jwkAsJsonString, 'ConvertKeyOutputTextArea');
			// ConvertKeyOutputTextArea
			return jwkAsJsonString;
		}

		function writeKeyToOutputTextArea(keyAsString, textAreaId){
			var textAreaById = document.getElementById(textAreaId);
			textAreaById.textContent = keyAsString;
			textAreaById.value = keyAsString;
		}

		function base64_arraybuffer(bytes){
			var binary = '';
			// var bytes = new Uint8Array( buffer );
			var len = bytes.byteLength;
			for (var i = 0; i < len; i++) {
				binary += String.fromCharCode( bytes[ i ] );
			}
			return window.btoa( binary );
		}
	</script>
</head>
<body>
	<h1>Convert keys</h1>
	<form style="display: grid; grid-template-columns: 1fr 1fr;">
		<fieldset style="grid-column: 1; grid-row: 1;">
			<legend>Input key</legend>
			<label for="ConvertKeyInputFormat">Input format: </label>
			<select id="ConvertKeyInputFormat" name="ConvertKeyInputFormat">
				<option value="pkcs">PEM</option>
				<option value="jwk">JWK</option>
				<option value="raw">Raw</option>
			</select>
			<br/>
			<label for="ConvertKeyInputTextArea">Input key</label>
			<textarea id="ConvertKeyInputTextArea"
				name="ConvertKeyInputTextArea"
				oninput="inputKeyFieldChange()"
				placeholder="Enter key to convert here"
				style="width: 97.5%; height: 20rem;"></textarea>
		</fieldset>
		<fieldset style="grid-column: 2; grid-row: 1;">
			<legend>Converted key</legend>
			<label for="ConvertKeyOutputFormat">Output Format: </label>
			<select id="ConvertKeyOutputFormat" name="ConvertKeyOutputFormat">
				<option value="jwk">JWK</option>
				<option value="pkcs">PEM</option>
				<option value="raw">Raw</option>
			</select>
			<br/>
			<label for="ConvertKeyOutputTextArea">Output key</label>
			<textarea id="ConvertKeyOutputTextArea"
				name="ConvertKeyOutputTextArea"
				placeholder="Converted key appears here"
				style="width: 97.5%; height: 20rem;"
				readonly></textarea>
		</fieldset>
	</form>
</body>
</html>
